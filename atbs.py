# -*- coding: utf-8 -*-
"""ATBS

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j4DsNYQiFy6NKws-FXDjX2YWbvqf7k-A

#Variables
"""

#Variables 
#can be overwritten
#assignment operator is =

spam = 50
eggs= 5
#operators include +,-,/,*,**,%,//
print(spam + eggs + spam + 2)
spam= spam + 12
print(spam)
spam= 'Hi, I am spam.'
print(spam)


#Accepting user input
print('What is your name?')
theirname= input()
print('Fuck you, ' + theirname)
#https://docs.python.org/3/library/functions.html for more built in functions
print('The length of your name is: .')
print(len(theirname)) #len() function

print('How old are you?')
theirage= input()
#need to convert variable from str (indicated within ' ') to int to use it for calculations - e.g. underneath takes theirage= int(theirage) and simplifies it
print('You will be ' + str(int(theirage) + 50) + ' years old in 1 year.')


#comparison/relational operators include ==(equal to), !=(not equal to), <(less than), >(greater than), <=(less than or equal to), and >=(greater than or equal to)
#These compare multiple values down to a single Boolean value (determine if true or false)
print('What is your username?')
username=input()
print('What is your password?')
password=input()
if username=='Milkman':
    print('Hi, Milkman')
    if password=='shitsandwich':
        print('You are in, my dude')
    else:
        print('Try again, dumbbass')
#elif statements only help with readability as nesting/indents aren't necessary
elif username!='Milkman':
    print('Are you sure?')


#while statements
#while loops made up of: "
#In the while loop, the condition is always checked at the start of each iteration
#If the condition is True, then the clause is executed, and afterward, the condition is checked again. The first time the condition is found to be False, the while clause is skipped.
spam= 0
while spam <5:
    print ('Hey, buddy')
    spam= spam + 1

while True:
    thename = input('Who dis?')
    if thename!= 'Joe':
        continue
    if thename == 'Joe':
        secretpassword = input('Hello, Joe. How old were you when you realized you were a faggot?')
        if secretpassword == '21':
            print('Access granted.')
            break

print('My name is')
i= 0
while i<5:
    print('Jimmy Five Times (' + str(i) + ')')
    i = i + 1

#for loops
#loops made up of: "for" + variable (e.g. i) + "in" "range()"
print('My name is')
for i in range(5):
    print('Jimmy Five Times (' + str(i) + ')')

#total variable is set to 0 when the program starts
total=0
for num in range(101): #num will represent each integer/number added from 0-100
    total= total + num
print(total)

#range function can also be called with 3 arguments - start (0) and stop (10) values, and the step argument (2, the amount that the variable is increased by after each iteration)
for i in range(0, 10, 2):
    print(i)

#import
#random.randint() function evaluates to a random integer value between the two integers that you pass it
#since randint() is in the random module, you must first type random in front of the function name to tell Python to look for this function inside the random module.
import random
for i in range(5):
    print(random.randint(1, 10))

#sys.exit() - this function is in the sys module, you have to import sys before your program can use it
import sys
while True:
    print('Type exit to exit.')
    response = input()
    if response == 'exit':
        sys.exit()
    print('You typed ' + response + '.')


#all together now
import random
RightNumber = random.randint(1, 20)

print('I am thinking of a number between 1 and 20.')

for GuessesTaken in range(1, 6): #player can guess 5 times; guessestaken is now a variable that the program will remember
    print('Take a guess.')

    guess = int(input()) #passing str into int

    if guess < RightNumber:
        print('Your guess is too low.')
    elif guess > RightNumber:
        print('Your guess is too high.')
    else:
        break #right answer! >>>> can use break as this is part of a for loop (can also use in a while loop)

if guess == RightNumber:
    print('Good job! You guessed my number in ' + str(GuessesTaken) + ' guesses!')
else:
    print('Nope. The number I was thinking of was ' + str(RightNumber)

"""#Def and for loops"""

#def statement 
#a type of higher order function that can take variables (that won't be altered) and/or lower order functions (e.g. regex)
#defines a function e.g. heyo(name) - groups code that gets executed multiple times

def heyo(name): #heyo is the function/program and "name" is the parameter that the function executes
    print('Hey, ' + name)
heyo('Alice') #the argument "Alice" is passed to th function and parameter name is automatically set to 'Alice'
heyo('John')
#the value stored in a parameter is forgotten when the function returns


#Rock, Paper, Scissors
import random, sys #calls random and sys modules for later

print('ROCK, PAPER, SCISSORS')

wins= 0
losses= 0
ties= 0

while True: #Main game loop

    while True: #Main player input loop

        print('Wins: ' + str(wins))
        print('Losses: ' + str(losses))
        print('Ties: ' + str(ties))

        print('Enter your move: (r)ock, (p)aper, (s)cissors, or (q)uit')
        playermove= input()
        if playermove== 'q':
            sys.exit() #quit
            print('Goodbye, thanks for playing')
        if playermove == 'r' or playermove == 'p' or playermove == 's':
            break #break out of player input loop and moves to next loop

    if playermove== 'p': #Player input chosen
        print('Paper versus...')
    if playermove== 's':
        print('Scissors versus...')
    if playermove== 'r':
        print('Rock versus..')

    move= random.randint(1,3) #AI choice
    if move== 1:
        AImove= 'p'
        print('PAPER')
    if move== 2:
        AImove= 's'
        print('SCISSOR')
    if move== 3:
        AImove= 'r'
        print('ROCK')

    if playermove== 'r' and AImove== 'r': #Decision tree and return wins/losses/ties
        print('It is a tie!')
        ties= ties + 1
    if playermove== 'p' and AImove== 'p':
        print('It is a tie!')
        ties= ties + 1
    if playermove== 'p' and AImove== 'p':
        print('It is a tie!')
        ties= ties + 1
    if playermove== 'r' and AImove== 's':
        print('You win!')
        wins= wins + 1
    if playermove== 's' and AImove== 'p':
        print('You win!')
        wins= wins + 1
    if playermove== 'p' and AImove== 'r':
        print('You win!')
        wins= wins + 1
    if playermove== 's' and AImove== 'r':
        print('You Suck!')
        losess= losses + 1
    if playermove== 'r' and AImove== 'p':
        print('You Suck!')
        losess= losses + 1
    if playermove== 'p' and AImove== 's':
        print('You Suck!')
        losess= losses + 1


#def statement defines a function e.g. heyo(name) - groups code that gets executed multiple times
def heyo(name): #heyo is the function/program and "name" is the parameter that the function executes
    print('Hey, ' + name)
heyo('Alice') #the argument "Alice" is passed to th function and parameter name is automatically set to 'Alice'
heyo('John')
#the value stored in a parameter is forgotten when the function returns


#Magic8Ball
import random

while True:
  def getanswer(fortune):
    print('What do you want to know?')
    question= input()
    if answer==1:
        return 'Yes'
    elif answer==2:
        return 'Maybe'
    elif answer==3:
        return 'No'

  answer= random.randint(1,3)
  fortune= getanswer(answer)

  print(fortune) #could simplify to print(getanswer(random.randint(1,3)))

spam = print('Hello!')
None == spam #Python adds return None to the end of any function definition with no return statement, similar to how a while or for loop implicitly ends with a continue statement


#sep and end optional parameters
print('Hello', end='')
print('World')

print('cats', 'dogs', 'mice', sep=',')


#Stack: main (global scope - created when program begins; global variables) > method 1 then 2, 3, 4, ect (local scope - created when a function is called; variables & function)
#Code in global scope can't access local variables but local variables can be accessed by global code
def spam():
    eggs = 'local'
    print(eggs)

def bacon():
    spam() #tells program to run function from spam or else it won't display it
    eggs = 'also local'
    print(eggs)

bacon() #tells program to run function from bacon or else it won't display it
eggs = 'global'
print(eggs)


#global variables
#to modify the value stored in a global variable from in a function, must use a global statement on that variable
def chickensandwich():
    global mayonnaise #tells program to not create a local variable with this name for this function
    mayonnaise= 'mmm Heinz'

mayonnaise= 'not Heinz'
chickensandwich()
print(mayonnaise)


#preventing crashes with try (if code potentially has a bug), the program execution immediately moves to the code in the except clause, after running that code, the execution continues as normal.
def error(divideby):
    try:
        return 24/divideby
    except:
        print('Error: invalid argument')
print(error(12))
print(error(0))


#forward and backwards astrisks
import time, sys #calls time and sys modules

indent= 0 #sets indent baseline to 0, keeps track of how many spaces of indent are before the band of astrisks
indentincrease= True #contains a Boolean value to determine if the amount of indentation is increasing or decreasing

try:
    while True: #repeats instructions forever
        print(' ' * indent, end='') #using ' ' * indent to print the correct amount of spaces of indentation, we don’t want to automatically print a newline after these spaces, so we also pass end=''
        print('*****') #calls band of atrisks
        time.sleep(0.1) #pauses for 1/10 of a second
        if indentincrease:
            indent= indent + 1
            if indent== 20:
                indentincrease= False #change indent direction to go backwards
        else:
            indent= indent - 1
            if indent==0:
                indentincrease= True #change indent direction to go forwards

except KeyboardInterrupt:
    sys.exit()

"""#Lists and for loops"""

#List data and for loops
#useful for storing groups of similar variables (e.g. owl breeds)
#lists can be stored within a variable between brackets, their place is indicated by [number] (aka index 1,2,3,ect)
# e.g. animals= ['chicken', 'cobra', 'dog'] #where chicken is animals[0], cobra is animals[1], and dog is animals[2]

list1= [['cat','cow'],[1,3,7,25], 'dingdong']
print(list1[1])
print(list1[1][3]) #calls upon number 25 in index 1 (spot 3)
print(list1[0:2]) #[:] is a slice that calls upon ['cat','cow'] (index 0) and [1,3,7,25] (index 1) in this case
print(list1[:]) #calls upon all in this list - [['cat','cow'],[1,3,7,25], 'dingdong']
len(list1) #return the number of values that are in a list


#can also use an index of a list to change the value at that index
spam = ['cat', 'bat', 'rat', 'elephant']
spam[1] = 'aardvark' #['cat', 'aardvark', 'rat', 'elephant']
spam[2] = spam[1] #['cat', 'aardvark', 'aardvark', 'elephant']
spam[-1] = 12345 #['cat', 'aardvark', 'aardvark', 12345]


#can concatante, replicate, or delete lists and indexes
[1, 2, 3] + ['A', 'B', 'C'] # adding results in [1, 2, 3, 'A', 'B', 'C']
['X', 'Y', 'Z'] * 3 #multiplying results in ['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z']
chocochocochip= ['dupe','slupe','poop']
del chocochocochip[1] #deleting results in ['dupe','slupe']


#for loops within lists
spoopyNames = []
while True:
    print('Enter the name of your imaginary friend ' + str(len(spoopyNames) + 1))
    name = input()
    spoopyNames = spoopyNames + [name]  # list concatenation
    if name == '':
      break
print('Your imaginary friend names are:')
for name in spoopyNames: #a for loop repeats the code block once for each item in a list value
   print('  ' + name)


#more for loops
supplies = ['pens', 'staplers', 'flamethrowers', 'binders']
for i in range(len(supplies)): #iterates over the indexes of a list
    print('Index ' + str(i) + ' in supplies is: ' + supplies[i])
#OR
supplies = ['pens', 'staplers', 'flamethrowers', 'binders']
for i, item in enumerate(supplies): #enumerates
    print('Index ' + str(i) + ' in supplies is: ' + supplies[i])


#can evaluate if an item is present in an index
myfucks= ['husband','Josh','cat','Melon','immediate family']

while True:
  print('Do I give a fuck about ...?')
  thing= input()
  if thing not in myfucks:
    print('No, I do not give a fuck about them')
  else:
    print('Yeah, I fucks with them')


#multiple assignments aka tuple unpacking
Trevor= ['ugly','mentally ill','a loser']
attractiveness, stability, disposition = Trevor #assign multiple variables with the values in a list in one line of code


#random.choice() and random.shuffle() functions
import random
pets= ['dragon','lump of coal','cheeseburger']

theone= random.choice(pets)
print(theone)

alltheones= random.shuffle(pets)
print(alltheones)


#augmented assignment operators
spam += 1 #means spam = spam + 1
spam -= 1 #means spam = spam - 1
spam *= 1 #means spam = spam * 1, another example could be cheez= ['donut'], then cheez *= 3. makes cheez into ['donut','donut','donut']
spam /= 1 #means spam = spam /
spam %= 1 #means spam = spam % 1


#concatante lists
yes = 'ding '
yes += 'a '
yes += 'ling'
print(yes)


#methods are the same thing as functions except they are called on a value (e.g. greet.index('hello'))
#append() and insert() methods are list methods and can be called only on list values, not on other values such as strings or integers
#if we wanted to save/update the list, we would write the "greet.append('yo') as greet= greet.append('yo')
greet= ['hi','hello','hey', 'hiya']
greet.index('hello') #index searches for a value in a list, if there are duplicates in a list, the method will only return the first instance

greet.append('yo') #append adds a value to the end of a list
print(greet)

greet.insert(1, 'herro') #insert tells the method where to insert a value
print(greet)

greet.remove('hey') #remove takes out a value to the end of a list when you know the value name
print(greet)

greet.reverse() #reverses order or values
print(greet)

greet.sort() #sorts strings alphabetically or integers by size. only works with single character types. could also sort ignoring capitalization via greet.sort(key=str.lower)
print(greet)

greet.sort(reverse=True) #reverses the sort order
print(greet)


#Cleaner magic 8 ball using lists
import.random
magic8ball= ['Yes', 'Definitely', 'No','Maybe', 'Could be']
print(magic8ball[random.randint(0, len(magic8ball) - 1)]) #this produces a random number to use for the index, regardless of the size of messages


#sequencing data types
name= 'Melon'
print(name[-2]) #prints value in list location
print(name[0:3]) #prints values within list locations

if 'Mel' in name: #evaluates if 'Mel' is in "name" variable
    print('True')

for i in name:
    print'* * * ' + i + ' * * *')


#A list value is a mutable data type: it can have values added, removed, or changed
#A string is immutable: it cannot be changed
#proper way to mutate a string is to slice and concatenate
chicken= 'this is a bird'
chicken= chicken[0:8] + 'the best' + chicken[9:14] #indicate location of characters to keep
print(chicken)


#truple data
#different from lists is that tuples, like strings, are immutable
#use tuples to convey to anyone reading your code that you don’t intend for that sequence of values to change
#because they are immutable and their contents don’t change, Python can implement some optimizations that make code using tuples slightly faster than code using lists
eggs = (('hello', 42, 0.5))
eggs[0]
#If you have only one value in your tuple, you can indicate this by placing a trailing comma after the value inside the parentheses
type(('hello',))
<class 'tuple'>
type(('hello'))
<class 'str'>


#id function
#When Python runs id('Howdy'), it creates the 'Howdy' string in the computer’s memory (numeric memory address) where the string is stored is returned by the id() function
#Python picks this address based on which memory bytes happen to be free on your computer at the time, so it’ll be different each time you run this code
Howdy= 3
print(id(Howdy))
Howdy += 4
print(id(Howdy)) #different id as variable was overwritten
#The same is not true for lists
Hi= [1,3,6]
print(id(Hi))
Hi.append(2)
print(id(Hi)) #same id as before


#passing references
def thething(someparameter):
    someparameter.append('hi')

theotherthing= [1, 3, 5, 7]
thething(theotherthing)

print(theotherthing)


#copy.copy()
#although passing around references is often the handiest way to deal with lists, if the function modifies the list that is passed, you may not want these changes in the original list
#If the list you need to copy contains lists, then use the copy.deepcopy()


#Game of Life
import random, time, copy

width= 60
height= 20

#create a list of lists for the cells
nextcells=[]
for x in range(width):
    column=[] #create a new column
    for y in range(height):
        if random.randint(0, 1)==0: #gives 50/50 chance of the cells starting off alive or dead
            column.append('#') #add living cell
        else:
            column.append(' ') #add dead cell
        nextcells.append(column) #nextcells is a list of column lists
        #x-coordinates start at 0 on the left and increases going right and y-coordinates start at 0 at the top and increases going down (nextCells[0][0] will represent the cell at the top left of the screen)
        #i.e. nextCells[0][0] will represent the cell at the top left of the screen, while nextCells[1][0] represents the cell to the right of that cell and nextCells[0][1] represents the cell beneath it

while True: #main program loop
    print ('\n\n\n\n\n') #separates each step with newlines
    currentcells= copy.deepcopy(nextcells) #the first step in our main program loop will be to copy nextCells into currentCells
    #print currentcells on the screen

    for y in range(height): #nested for loops ensure that we print a full row of cells to the screen, followed by a newline character at the end of the row
        for x in range(width):
            print(currentcells[x][y], end='') #print either living or dead cells
        print() #print a newline at the end of the row

    #calculate the next step's cells based on current step's cells:
    for x in range(width):
        for y in range(height):
            #get neighboring coordinates
            #% mod operator performs a “wraparound.” The left neighbor of a cell in the leftmost column 0 would be 0 - 1 or -1
            #to wrap this around to the rightmost column’s index, 59, we calculate (0 - 1) % WIDTH
            leftcoord= (x-1) %width
            rightcoord= (x+1) %width
            abovecoord= (y-1) %height
            belowcoord= (y+1) %height
            #count number of living cells
            #checks each of the eight neighbors of this cell, and adds 1 to numberofneighbors for each living one
            numberofneighbors= 0
            if currentcells[leftcoord][abovecoord]== '#':
                numberofneighbors+= 1 #top-left neighbor is alive
            if currentcells[x][abovecoord]== '#':
                numberofneighbors+= 1 #top neighbor is alive
            if currentcells[rightcoord][abovecoord]== '#':
                numberofneighbors+= 1 #top-right neighbor is alive
            if currentcells[leftcoord][y]== '#':
                numberofneighbors+= 1 #left neighbor is alive
            if currentcells[rightcoord][y]== '#':
                numberofneighbors+= 1 #right neighbor is alive
            if currentcells[leftcoord][belowcoord]== '#':
                numberofneighbors+= 1 #bottom-left neighbor is alive
            if currentcells[x][belowcoord]== '#':
                numberofneighbors+= 1 #bottom neighbor is alive
            if currentcells[rightcoord][belowcoord]== '#':
                numberofneighbors+= 1 #bottom-right neighbor is alive
            #Conway's Game of Life rules:
            if currentcells[x][y]== '#' and (numberofneighbors== 2 or numberofneighbors==3): #living cells with 2 or 3 neighbors stay alive
                nextcells[x][y]= '#'
            elif currentcells[x][y]== ' ' and numberofneighbors== 3:  # dead cells with 3 neighbors become alive
                nextcells[x][y]= '#'
            else: # everything else dies or stays dead:
                nextcells[x][y]= ' '
    time.sleep(1) #add 1 sec pause to reduce flickering


#heart grid
grid=[['.', '.', '.', '.', '.', '.'],
    ['.', 'O', 'O', '.', '.', '.'],
    ['O', 'O', 'O', 'O', '.', '.'],
    ['O', 'O', 'O', 'O', 'O', '.'],
    ['.', 'O', 'O', 'O', 'O', 'O'],
    ['O', 'O', 'O', 'O', 'O', '.'],
    ['O', 'O', 'O', 'O', '.', '.'],
    ['.', 'O', 'O', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.']]
for i in range(len(grid[0])):
    #need to count from 0 to len(grid[0]) -that's the number of items in the first list
    # then for i in range(6 in this case) loop the following print 6 times, which means 6 rows in our output grid
    for j in range(len(grid)):
        # len(grid) gets the length of input grid, which is the row numbers
        # then for j in range(9) means we will 9 items for each row
        print(grid[j][i],end='')
    print('')

"""# Dictionaries"""

#dictionary (indicated by {})
        '''
        #mutable collection of many values
        #indexes for dictionaries (called keys) can use many different data types
        #indexes for dictionaries are called keys, and a key with its associated value is called a key-value pair
        #items in dictionaries are unordered. The first item in a list named spam would be spam[0] but there is no “first” item in a dictionary
        #it does not matter in what order the key-value pairs are typed in a dictionary to determine if two dictionaries are the same (unline lists)
        #can’t be sliced like lists
        '''

myCat = {'size': 'big', 'disposition': 'loud'} #where size and disposition are keys and big and loud are values that can be accessed through their keys
print('My cat, Melon, is ' + myCat[size] + ' and ' + myCat[disposition] + '.')


birthdays = {'Alice': 'Apr 1', 'Bob': 'Dec 12', 'Carol': 'Mar 4'}

while True:
    print('Enter a name: (blank to quit)')
    name = input()
    if name == '':
        break

    if name in birthdays:
        print(birthdays[name] + ' is the birthday of ' + name)
    else:
        print('I do not have birthday information for ' + name)
        print('What is their birthday?')
        bday = input()
        birthdays[name] = bday
        print('Birthday database updated.')


#keys(), values(), and items() methods
#return by these methods are not true lists: they cannot be modified and do not have an append() method
#these data types (dict_keys, dict_values, and dict_items, respectively) can be used in for loops

buffalo= {'colour': 'brown', 'age': '24'}
for i in buffalo.values(): #prints values
    print(i)
for i in buffalo.keys(): #prints keys
    print(i)
print(list(buffalo.keys())) #provides a true list from one of these methods by passing it's list-like return value to list()
for i, j in buffalo.items(): #prints key and value
    print('key: ' + i + 'value: ' + str(j))
#if you ever want to check whether a value is (or isn’t) a key in the dictionary, you can simply use the in (or not in) keyword with the dictionary value itself


#get() and setdefault() methods
#get(): takes two arguments: the key of the value to retrieve and a fallback value to return if that key does not exist

picnicBasket= {'sandwiches':5, 'plates':5}
print('I am bringing ' + str(picnicBasket.get('plates',0)) + 'plates.') #get() where 0 is default value
print('I am bringing ' + str(picnicBasket.get('cups',0)) + 'cups.')

#setdefault(): first argument passed to the method is the key to check for, and the second argument is the value to set at that key if the key does not exist
#if the key does exist, the setdefault() method returns the key’s value

dogQualities= {'size': 'large', 'fur length': 'medium', 'energy levels': 'high'}
dogQualities.setdefault('colour', 'brown') #equivalent to: if 'colour' not in dogQualities > dogQualities['colour']= 'brown'
print(dogQualities)


#Finds how many instances of a character are in a string
while True:
    print ('What text would you like to analyze?')
    message= input()
    if message == '':
        break
    while True:
        print('Which letter are you looking for?')
        letter= input()
        if letter in message:
            letterCount= message.count(letter)
            print('There are ' + str(letterCount) + ' in this text.')
        else:
            print('Sorry, there is no ' + letter + ' in this text.')

#Finds how many of each character are in a string
import pprint #PRETTY PRINTING

while True:
    print ('What text would you like to analyze?')
    message= input()
    if message== '':
        pprint.pprint('Goodbye') helpful when the dictionary itself contains nested lists or dictionaries.
        #If you want to obtain the prettified text as a string value instead of displaying it on the screen, call pprint.pformat() instead
        break
    else:
        letterCount={}
        for letter in message:
            letterCount.setdefault(letter,0)
            letterCount[letter]= letterCount[letter] + 1
        pprint.pprint(letterCount)


#Implementation of Two Player Tic-Tac-Toe game in Python

#make a board using dictionary in which keys will be the location
theBoard = {'7': ' ' , '8': ' ' , '9': ' ' ,
            '4': ' ' , '5': ' ' , '6': ' ' ,
            '1': ' ' , '2': ' ' , '3': ' ' }

board_keys = []

for key in theBoard:
    board_keys.append(key)

#print the updated board after every move in the game by define printBoard function and calling this function every time
def printBoard(board):
    print(board['7'] + '|' + board['8'] + '|' + board['9'])
    print('-+-+-')
    print(board['4'] + '|' + board['5'] + '|' + board['6'])
    print('-+-+-')
    print(board['1'] + '|' + board['2'] + '|' + board['3'])

#write the main function which has all the gameplay functionality
def game():

    turn = 'X'
    count = 0

    for i in range(10):
        printBoard(theBoard)
        print("It's your turn," + turn + ".Move to which place?")

        move = input()

        if theBoard[move] == ' ':
            theBoard[move] = turn
            count += 1
        else:
            print("That place is already filled.\nMove to which place?")
            continue

        #check if player X or O has won,for every move after 5 moves
        if count >= 5:
            if theBoard['7'] == theBoard['8'] == theBoard['9'] != ' ': # across the top
                printBoard(theBoard)
                print("\nGame Over.\n")
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['4'] == theBoard['5'] == theBoard['6'] != ' ': # across the middle
                printBoard(theBoard)
                print("\nGame Over.\n")
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['1'] == theBoard['2'] == theBoard['3'] != ' ': # across the bottom
                printBoard(theBoard)
                print("\nGame Over.\n")
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['1'] == theBoard['4'] == theBoard['7'] != ' ': # down the left side
                printBoard(theBoard)
                print("\nGame Over.\n")
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['2'] == theBoard['5'] == theBoard['8'] != ' ': # down the middle
                printBoard(theBoard)
                print("\nGame Over.\n")
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['3'] == theBoard['6'] == theBoard['9'] != ' ': # down the right side
                printBoard(theBoard)
                print("\nGame Over.\n")
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['7'] == theBoard['5'] == theBoard['3'] != ' ': # diagonal
                printBoard(theBoard)
                print("\nGame Over.\n")
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['1'] == theBoard['5'] == theBoard['9'] != ' ': # diagonal
                printBoard(theBoard)
                print("\nGame Over.\n")
                print(" **** " +turn + " won. ****")
                break

        #if neither X nor O wins and the board is full, we'll declare the result as 'tie'
        if count == 9:
            print("\nGame Over.\n")
            print("It's a Tie!!")

        #change the player after every move
        if turn =='X':
            turn = 'O'
        else: #if 'O' turn, then will make 'X' turn
            turn = 'X'

    #ask if player wants to restart the game or not
    restart = input("Do want to play Again?(y/n)")
    if restart == "y" or restart == "Y":
        game()

game()


#nesting lists
guests= {'Chink':{'cheese': 4, 'dildos': 12},
        'Coochie':{'dildos': 3, 'pubes': 7}}
def numBrought(guests, item):
    numBrought= 0
    for i,j in guests.items():
        numBrought= numBrought + j.get(item,0)
    return numBrought
print('Number of things brought')
print(' - dildos - ' + str(numBrought(guests, 'dildos')))


#Fantasy gamestuff

stuff= {'Arrows': 12, 'Gold': 157, 'Mana': 3, 'Health': 7}

def displayInventory(inventory):
    total_items = 0
    for item, quantity in inventory.items():
        print(item + ' ' + str(quantity))
        total_items += quantity
    print('Total number of items: ' + str(total_items))

displayInventory(stuff)

dragonLoot= {'Gold': 20, 'Diamond': 3}

def addToInventory(dragonLoot, addedItems):
    for item in dragonLoot:
        inventory.setdefault(item, 0) #this adds a (defaulted to zero value) key to the inventory dict if it's not already there
        inventory[item] += 1 #and this increases that value by one, each time that item appears in the loot list
    return inventory

displayInventory(stuff)

"""#Manipulating strings"""

!pip install Pyperclip

#Strings and while loops

#string literals
print("That's the Devil's lettuce") #double quotes
print('That\'s not the Devil\'s lettuce') #escape character

#new line is \n
#backslash is \\
#tab is \t

print("Hello there!\nHow are you?\nI\'m doing fine.")

#raw strings
print(r'That is the dog\'s shit') #completely ignores all escape characters and prints any backslash that appears in the string

#multiline strings
print('''Dear Dumbass,

Eve's cat has been arrested for burglary and extortion.

Sincerely,
Bob''')


#indexing strings
#strings are indexed like lists are e.g. 'Fuck' where F is 0, u is 1, c is 2, and k is 3

#slicing strings
chicken= 'Fuck off'
chick= chicken[0:3]
print(chick)

#in and not in operators with strings
'Jesus' in 'Prostitute' #false

#strings in other strings
name= 'poop'
smell= 'smelly'
print('my name is %s. I am %.')%(name, smell) #can use % then ()
print(f'my name is {name}. I am {smell}') #cal also use f then {}

#convert strings to upper or lowercase
string1= 'cheese'
string1= string1.upper() #upper() for uppercase
print(string1)

string2= 'CHEESE'
string2= string2.lower() #lower() for lowercase
print(string2)

print(string2.islower()) #check if string has lowercase letters in it; can do same with uppercase letters


print('How the fuck are ya?')
feels= input()
if feels.lower()== 'awesome': #won't matter if input is capitalized
    print("fuckin' great")
else:
    print("that fuckin' sucks")

#isX() method

#isalpha() returns True if the string consists only of letters and isn’t blank
#isalnum() returns True if the string consists only of letters and numbers and is not blank
#isdecimal() returns True if the string consists only of numeric characters and is not blank
#isspace() returns True if the string consists only of spaces, tabs, and newlines and is not blank
#istitle() returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters

while True:
    age= int(input('How old are you?'))
    if age.isalpha():
        print('Please enter a number for your age')
        continue
    if age.isdecimal():
        print('Thx')
        break
while True:
    passport= input('Please enter a username')
    if passport.isalnum():
            break
    else:
        print('Passwords can only have letters and numbers only')
        continue


#startswith() and endswith()
print('Hello, world!'.endswith('world!'))


#join() and split()
doopy= '''Dear, Fartknocker,

I like the way your face looks...
when I sit on it.

Sincerely,

Fuck juice'''

print(doopy,split('/n') #lets us split the multiline string stored in spam along the newlines


#partition() string method can split a string into the text before and after a separator string
#is useful for splitting a string whenever you need the parts before, including, and after a particular separator string
print('Hello, world!'.partition('w'))

before, sep, after = 'Hello, world!'.partition(' ') #multiple assignment trick assigns the three returned strings to three variables
print(before)
print(sep)
print(after)


#justifying text with rjust(), ljust(), and center() methods
print(len('there are 28 characters here'))
print('there are 28 characters here'.rjust(30, '*')) #rjust adds 2 *s to the right so that string is 30 characters
print('Porn'.center(10, '#'))


girls= {'Normal': '$5', 'Fat': '$1', 'Tranny': '$100'}
def girlsForSale(girls, leftWidth, rightWidth): #takes in a library (girls) and arguments(width)
    print('GIRLS'.center(leftWidth + rightWidth, '-'))
    for g, p in girls.items():
        print(g.ljust(leftWidth, '.') + p.rjust(rightWidth)) # lets you ensure that strings are neatly aligned, even if you aren’t sure how many characters long your strings are
girlsForSale(girls, 10, 4) #provides number of characters for the right and left column to def girlsForSale()


#removing whitespace
#.strip() can be used generally, right side (.rstrip()) and left side (.lstrip())
song= '        Reduce, re-use, recycle          '
print(song.strip())

censorship= 'Fuck hello :)'
censorship= censorship.strip('Fuck') #stripping for the kids
print(censorship)


#Unicode code point

print(ord('a'))
print(chr(97))
print(ord('A') < ord('B'))


#pyperclip module
#has a copy() and paste() function that can send text to and receive text from your computer’s clipboard

#! python3
#pasting from clipboard
TEXT = {'okay': """Thanks for letting me know""",
        'no': """Not interested. Thanks"""}

import sys, pyperclip

if len(sys.argv) <2: #argument is the key phrase of the message you want
#display a usage message to the user if they forget to add it (that is, if the sys.argv list has fewer than two values in it
    print('Usage: python mclip.py [keyphrase] - copy phrase text')
    sys.exit()
keyphrase = sys.argv[1]

if keyphrase in TEXT:
    pyperclip.copy(TEXT[keyphrase])
    print('Text for ' + keyphrase + ' copied to your clipboard')
else:
    print('There is no text for ' + keyphrase)

'''On Windows, you can create a batch file to run this program with the WIN-R Run window.
Enter the following into the file editor and save the file as mclip.bat in the C:\Windows folder:

@py.exe C:\path_to_file\mclip.py %*
@pause

With this batch file created, running the multi-clipboard program on Windows is just a matter of pressing WIN-R and typing mclip key phrase.'''


#! python3#bulletpointadder.py
#pasting from clipboard, adding stars
import pyperclip

text= pyperclip.paste()
pyperclip.copy(text)

lines= text.split('\n')
for i in range(len(lines)): #loop through all indexes in the "lines" list
    lines[i]= '* ' + lines[i] #add star to each string in "lines" list
text= '\n'.join(lines) #to make this single string value, pass lines into the join() method to get a single string joined from the list’s strings
pyperclip.copy(text)


# English to Pig Latin
print('Enter the English message to translate into Pig Latin:')
message = input()

VOWELS = ('a', 'e', 'i', 'o', 'u', 'y')

# piglatin[] will be a place where the words in Pig Latin will be stored
pigLatin = []
for word in message.split():

    # Separate the non-letters at the start of this word and stores them in prefixNonLetters
    prefixNonLetters = ''
    while len(word) > 0 and not word[0].isalpha():
        prefixNonLetters += word[0]
        word = word[1:]
    if len(word) == 0:
        pigLatin.append(prefixNonLetters)
        continue

    # Separate the non-letters at the end of this word and stores them in suffixNonLetters
    suffixNonLetters = ''
    while not word[-1].isalpha():
        suffixNonLetters += word[-1]
        word = word[:-1]

    # Remember if the word was in uppercase or title case
    wasUpper = word.isupper()
    wasTitle = word.istitle()

    # Make the word lowercase for translation
    word = word.lower()

    # Separate the consonants at the start of this word
    prefixConsonants = ''
    while len(word) > 0 and not word[0] in VOWELS:
        prefixConsonants += word[0]
        word = word[1:]

    # Add the Pig Latin ending to the word:
    if prefixConsonants != '':
        word += prefixConsonants + 'ay'
    else:
        word += 'yay'

    # Set the word back to uppercase or title case
    if wasUpper:
        word = word.upper()
    if wasTitle:
        word = word.title()

    # Add the non-letters back to the start or end of the word
    pigLatin.append(prefixNonLetters + word + suffixNonLetters)

# Join all the words back together into a single string
print(' '.join(pigLatin))

"""#Regex"""

#Pattern Recognition

#find the phone numbers
'''phoneNumbers= []
text= input('Enter some numbers')
for n in text.split():
    if len(text) == 10 and text.isnumeric() == True:
        phoneNumbers.append(n)
print(phoneNumbers)'''


#is phone number?
def isPhoneNumber(text):
    # must be 12 characters long
    if len(text) != 12:
        return False
    # characters between 0-3 must be numbers
    for i in range(0, 2):
        if not text[i].isnumeric():
            return False
    # character 3 and 7 must be hyphens
    if text[3 and 7] != '-':
        return False
    # characters between 4-7 must be numbers
    for i in range(4, 7):
        if not text[i].isnumeric():
            return False
    # characters between 8-12 must be numbers
    for i in range(8, 12):
        if not text[i].isnumeric():
            return False
    return True

for i in range(len(message)):
  chunk = message[i:i+12] # on each iteration of the for loop, a new chunk of 12 characters from message is assigned to the variable chunk
  if isPhoneNumber(chunk):
    print('Phone number found: ' + chunk)

#You pass chunk to isPhoneNumber() to see whether it matches the phone number pattern, and if so, you print the chunk
#Continue to loop through message, and eventually the 12 characters in chunk will be a phone number
#The loop goes through the entire string, testing each 12-character piece and printing any chunk it finds that satisfies isPhoneNumber()



#Regular expressions
#Regexes - descriptions for a pattern of text
#To search for them, these characters need an escape character before them: .  ^  $  *  +  ?  {  }  [  ]  \  |  (  )
#the regex \d{3}-\d{3}-\d{4} (aka \d\d\d-\d\d\d-\d\d\d\d) is used by Python to match the same text pattern the previous isPhoneNumber() function did

'''
CHARACTER MATCHING
.: matches any character except newlines
(.*): matches everything and anything
\d: Any numeric digit from 0 to 9
\D: Any character that is not a numeric digit from 0 to 9
\w: Any letter, numeric digit, or the underscore character
\W: Any character that is not a letter, numeric digit, or the underscore character
\s: Any space, tab, or newline character
\S: Any character that is not a space, tab, or newline

REGREX SYMBOLS
? matches zero or one of the preceding group.
* matches zero or more of the preceding group.
+ matches one or more of the preceding group.
{n} matches exactly n of the preceding group.
{n,} matches n or more of the preceding group.
{,m} matches 0 to m of the preceding group.
{n,m} matches at least n and at most m of the preceding group.
{n,m}? or *? or +? performs a non-greedy match of the preceding group.
^spam means the string must begin with spam.
spam$ means the string must end with spam.
. matches any character, except newline characters.
(.*) matches everything and anything
\d, \w, and \s match a digit, word, or space character, respectively.
\D, \W, and \S match anything except a digit, word, or space character, respectively.
[abc] matches any character between the brackets (such as a, b, or c).
[^abc] matches any character that isn’t between the brackets.

FLAGS
( , re.DOTALL) searches for all characters, even newlines
( , re.I) ignores capitalizations
( , re.VERBOSE) ignores whitespaces
'''

import re

#search() returns a Match object of the first matched text in the searched string
phoneNumRegex = re.compile(r'(\d\d\d)(\d\d\d-\d\d\d\d)')
mo = phoneNumRegex.search('My number is 415-555-4242.') #search will return 'None' if regex pattern is not found in the string
print('Phone number found: ' + mo.group()) #mo is a generic name for Match objects grouped into () - e.g. mo.group(2) is '(\d\d\d-\d\d\d\d)'
areaCode, mainNumber = mo.groups() #retrieves all groups at once
print(areaCode)
print(mainNumber)


#variations to find
batRegex= re.compile(r'Bat(man|mobile|copter|bat)') #pipe character aka bitwise/operator is |
mo3= batRegex.search('The Adventures of Batman')
print(mo3.group())


#optional finds
numaNumaRegex= re.compile(r'numa numa(Yeah)?') #(yeah)? makes numaYeah an optional find
mo1= numaNumaRegex.search('numa numa')
print(mo1.group())
mo2= numaNumaRegex.search('numa numaYeah')
print(mo2.group())


# ()+ means that at least one instance needs to be found e.g. Bat(wo)+man where there needs to be one BatWOman found
# ()* means it will match () as many times as is found (e.g. Bat(wo)*man - Batwowowowowowoman
# ()?: non-greedy


#matching specific repetitions with braces
#{3,} matches 3 or more instances. {,5} matches between 0 and 5 instances
#greedy matching spits out the upper limit number of instances
#non-greedy matching spits out the lower limit number of instances  '(Ha){1,4}?'
funniRegex= re.compile(r'(Ha){2,5}') #indicates that it can search for HaHa, HaHaHa, HaHaHaHa, or HaHaHaHaHa
mo4= funniRegex.search('HaHaHaHaHa')
print(mo4.group())
mo5= funniRegex.search('HeHeHeHe')
print(mo5.group())


#findall() returns the strings of every match in the searched string

phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') # has no groups
print(phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000'))

phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d)-(\d\d\d\d)') # has groups
print(phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000'))


#character classes
ducksRegex= re.compile(r'\d+\s\w+')
print(ducksRegex.findall('5 geese, 3 chickens, 7 whales'))


#custom character classes
penis= re.compile(r'[drpei]')
print(penis.findall('big, small, long, micro'))
pussy= re.compile(r'[^gbqyxuo]') #negative character class - matches all characters that are not in the character class
print(pussy.findall('fat, hairy'))


# ^ at the start of a regex to indicate that a match must occur at the beginning of the searched text
# $ at the end of the regex to indicate the string must end with this regex pattern
# ^ and $ used together to indicate that the entire string must match the regex


example= re.compile(r'\D+$')
example.search('Fuck ya life') #prints <re.Match object; span=(11, 12), match='e'>


otherexample= re.compile(r'<.*?>') #'r' (raw string), '< and >' (character we lookin for), '.*' (anything and everything), '?' (not greedy)
print(otherexample.findall('<You almost made me drop my croissant.>'))



#Flags
#combined flags = re.compile(r' ', re.IGNORECASE | re.DOTALL | re.VERBOSE)

#re.DOTALL searches for all characters, even newlines
chinesefoo= re.compile(r'.*', re.DOTALL)
print(chinesefoo.findall('Wha \n you n\ won'))

#case insensitive searching
#re.IGNORECASE or re.I
dinosaur= re.compile(r'.*', re.I)
print(dinosaur.search('WaLk LiKe A dInOsAur').group())

#substuting text
#sub() method

agent= re.compile(r'hand', re.I)
print(agent.sub('pussy', 'Sam took the carrot and put it in her Hand')) #second argument added to sub word

friend= re.compile(r'friend (\w)\w*')
print(friend.sub(r'\1****', 'My friend Adam made his friend Booke a burrito'))

#ignoring whitespaces
#re.VERBOSE

phone= re.compile(r'''(
(\d{3}|\(\d{3}\))? #area code may or may not be present, if present, may be surrounded by '()'
(\s|-|\.)? #separator if present
\d{3} #first 3 digits
(\s|-|\.) #separator
\d{4} #last 4 digits
(\s*(ext|x|ext.)\s*\d{,5})? #extension is present
)''', re.VERBOSE) #ignore newlines



#Search for phone numbers and email addresses
import re

#ask for text to analyze
text= input('Please enter a string of text, and I will output the phone numbers and emails found within.')

#defining what a phone number will look like
phoneRegex = re.compile(r'''
    (
    (\d{3}|\(\d{3}\))?                # optional area code
    (\s|-|\.)?                        # optional separator
    (\d{3})                           # first 3 digits
    (\s|-|\.)                         # separator
    (\d{4})                           # last 4 digits
    (\s*(ext|x|ext.)\s*(\d{2,5}))?    # extension
    )
    ''', re.VERBOSE)

#defining what an email address will look like
emailRegex= re.compile(r'''
    (
    [a-zA-Z0-9._%+-]+      # username
    @                      # @ symbol
    [a-zA-Z0-9.-]+         # domain name
    (\.[a-zA-Z]{2,4})      # dot-something
    )
    ''', re.VERBOSE)

#place to store matches
matches= []

#search for phone numbers and add to matches
for groups in phoneRegex.findall(text):
    phoneNum= '-'.join([groups[1], groups[3], groups[5]])
    if groups[8] != '':
        phoneNum += ' x' + groups[8]
    matches.append(phoneNum)

#search for email addresses and add to matches
for groups in emailRegex.findall(text):
       matches.append(groups[0])

#prints matches if found
if len(matches) > 0:
    print('\n'.join(matches))
else:
    print('No phone numbers or email addresses found.')
    
    

#Valid Date Detector
import re

#library of months and their corresponding days
thirtyOne= [1, 3, 5, 7, 8, 10, 12]
thirty= [4, 6, 9, 11]

#print date template
print("Please enter the current date: YYYY/DD/MM")

#accept date
date= input()

def validDate(validDater):
    # detect YYYY/DD/MM format
    validDater= re.compile(r"([1-2]\d\d\d)/(\d\d)/(\d\d)")

    #set variables for year, day, and month
    year = int(validDater.search(date).group(1))
    day = int(validDater.search(date).group(2))
    month = int(validDater.search(date).group(3))

    #checking number of days in the month
    if month in thirtyOne and day > 31:
        return "False: too many days in the month!"
    if month in thirty and day > 30:
        return "False: too many days in the month!"
    # feb exception
    if month == 2:
        if day > 28 and year % 4 != 0 and year % 100 != 0: # the year is not leap year
            return "False: too many days in the month!"
        elif day > 29 and year % 4 == 0 and year % 100 == 0:
            return "False: too many days in the month!"
    
    #return values if True 
    return year, day, month

#run program 
print(validDate(date))

"""#Input validation - pyinputplus"""

!pip install PyInputPlus

#Input validation - checks that values entered by the user, such as text from the input() function, are formatted correctly
#perform input validation by repeatedly asking the user for input until they enter valid text

while True:
    print("Please enter your age.")
    age= input()
    try:
        age= int(age)
    except: #what to do when entered incorrectly 
        print("Please enter your real age, don't bullshit me, boy.")
        continue 
    if age < 1:
        print("Fuck off, I'm serious. Give me your real age.")
        continue 
    break 
print(f"You're {age} years old. Thanks.") #could be written as ("You're ", age, "years old. Thanks.")


#PyInputPlus module 
'''
-Contains functions similar to input() but for numbers, dates, email addresses, ect
-If the user ever enters invalid input, such as a badly formatted date or a number that is outside of an intended range, PyInputPlus will reprompt them for input 
-Contains feature for limiting the number of reprompts and another with a timeout function 

-Activated via import pyinputplus

Functions:
inputStr() Is like the built-in input() function but has the general PyInputPlus features
inputNum() Ensures the user enters a number and returns an int or float
inputChoice() Ensures the user enters one of the provided choices
inputMenu() Is similar to inputChoice(), but provides a menu with numbered or lettered options
inputDatetime() Ensures the user enters a date and time
inputYesNo() Ensures the user enters a “yes” or “no” response
inputBool() Is similar to inputYesNo(), but takes a “True” or “False” response and returns a Boolean value
inputEmail() Ensures the user enters a valid email address
inputFilepath() Ensures the user enters a valid file path and filename, and can optionally check that a file with that name exists
inputPassword() Is like the built-in input(), but displays * characters as the user types so that passwords, or other sensitive information, aren’t displayed on the screen

help(pyip.inputChoice) provides info on each of the functions
'''


#min, max, greaterThan, and lessThan

import pyinputplus as pyip 

min= pyip.inputNum('Enter num: ', min=4)

lessThan= pyip.inputNum('Enter num: ', min=4, lessThan=6) #can do same with max and greaterThan


#limit, timeout, and default 

limit= pyip.inputNum(limit=6) #will allow user to try entering 6 inputs before stopping

timeout= pyinputNum(timeout=10) #will timeout user entry after 10 seconds

default= pyinputNum(limit=2, default= 'N/A') #returns the string 'N/A' when limit is reached 


#allowRegexes and blockRegexes
#if you specify both an allowRegexes and blockRegexes argument, the allow list overrides the block list

regexThings= pyip.inputStr(allowRegexes=[r'caterpillar', 'category'], blockRegexes=[r'cat'])


#blank 
#by default, blank input isn’t allowed unless the blank keyword argument is set to True
#use if you want to make input optional (optional input)

blank = pyip.inputNum('Enter num: ')
blank2= pyip.inputNum('Enter num: ', blank= True)


#custom validation function
#accepts a single string argument of what the user entered 
#raises an exception if the string fails validation 
#returns non-none value if input(custom) should return a different string from the one the user entered
#is passed as the first argument to inputCustom()

print('Please enter digits that add up to 10: ')
def addsUpToTen(numbers):
  numbersList= list(numbers)
  for i, digit in enumerate(numbersList):
    numbersList[i]= int(digit)
  if sum(numbersList) != 10:
    raise Exception ('The digits must add up to 10, not %s.' %(sum(numbersList)))
    return int(numbers)

response= pyip.inputCustom(addsUpToTen)

#yes/no 

while True:
  prompt= 'What to know how to keep a dump-truck asses bitch busy for hours?'
  response= pyip.inputYesNo(prompt)
  if response== 'no': 
    break 


#Random multiplication question generator 
import pyinputplus  as pyip
import random, time

numberOfQuestions= 10 #number of questions that will be asked
correctAnswers= 0 #where tally of correct answers will be stored

for questionNumber in range(numberOfQuestions):
  #Pick 2 numbers
  num1= random.randint(0,9)
  num2= random.randint(0,9)

  #Question prompt - takes 2 random numbers to multiply
  prompt= '%s: %s x %s = ' %(questionNumber, num1, num2)
  
  #Answers handled by regex
  try:
    pyip.inputStr(prompt, 
                  allowRegexes=['^%s$' % (num1 * num2)], # '%s' is replaced by the correct answer, '^' and '%' characters ensure that the answer begins and ends with the correct number
                  blockRegexes=[('.*', 'Incorrect!')], #'.*' matches anything and everything, if the user response doesn’t match the correct answer, the program will reject any other answer they provide
                  timeout=8, limit=3) #limits time to answer and number of tries
    
  #exception type is in the PyInputPlus module, so pyip. needs to prepend them
  #What to do in the instance of a timeout
  except pyip.TimeoutException: 
    print('You outta time')  
  #What to do in the instance where too many tries are made
  except pyip.TryLimitException:
    print('No mo tries')
    
  #What to do if none of these exceptions are raised (i.e. correct answer was found)
  else:
    print('Correct!')
    correctAnswers += 1
    
  #Brief pause to let user see the result
  time.sleep(1) 
  print('Score: %s / %s' % (correctAnswers, numberOfQuestions))


#Sandwich order

#dictionaries of sandwich parts and their prices
sandwichComponents = {'tomatoes': 0.50, 'lettuce': 0.20, 'onions': 0.20, 'cheddar cheese': 0.50}
bread = {'white': 2.00, 'whole wheat': 2.20}

#variable to store price total 
sandwichIngredients = []
priceTotal = 0
breadPrice = 0
componentsPrice = 0

for key in sandwichComponents:

    #prompting and accepting response 
  answer = pyp.inputYesNo(f'Would you like {key} on your sandwich? \n') #f needed to insert value

    #what will happen if you say yes, no, or something else
  if answer == 'yes':
    sandwichIngredients.append(key)
  if answer == 'no':
    continue

#retrieving prices from dictionary 
print(f'Your sandwich ingredients are as follows: {sandwichIngredients} \n')
for item in sandwichIngredients:
  price = sandwichComponents[item]
  #print(f'{item} = {sandwichComponents[key]}')
  componentsPrice += price

for b in bread.items():

  #prompting and accepting response
  answer = pyp.inputStr('Would you prefer white or whole wheat bread? /n', allowRegexes= [r'white', 'whole', 'whole wheat'])
  
  #what will happen if you white or whole wheat
  if answer == 'white':
    breadPrice += 2.00
    break
  if answer == 'whole' or 'whole wheat':
    breadPrice += 2.20
    break

#add prices together
priceTotal= componentsPrice + breadPrice

#print price total
print('The total for your sandwich is $', priceTotal)

"""# Reading & Writing Files"""

!pip install pathlib

#pathlib module

'''
C:\ (Windows), / (mac and Linux) is root folder
D:\ (Windows), folder in /Volumes (mac), folder in /mnt (Linux) are Volumes
\ (Windows) and \ (mac and Linux) are paths between folders

#If you pass it the string values of individual file and folder names into Path() - will return a string with a file path using the correct path separators
'''

from pathlib import Path
Path('ginger')
str(Path('ginger')) #gets a simple text string of this path
#output results in backslashes doubled because each backslash needs to be escaped by another backslash character


Path('spam') / 'bacon' / 'eggs'
Path('spam') / Path('bacon/eggs')
Path('spam') / Path('bacon', 'eggs') 
#All 3 result in PosixPath('spam/bacon/eggs')
#Using the / operator with Path objects makes joining paths easier and safer than using string concatenation or the join() method

#Python evaluates the / operator from left to right and evaluates to a Path object, so either the first or second leftmost value must be a Path object for the entire expression to evaluate to a Path object


#Every program that runs on your computer has a current working directory (cwd)

from pathlib import Path
import os 
Path.cwd() #gets string value with the cwd


#Home directory
#In C:Users (Windows), /Users (mac), /home (Linux)
#Ideal place to put Python programs
Path.home()


#Absolute and relative paths
'''
An absolute path, which always begins with the root folder
A relative path, which is relative to the program’s current working directory

A single period (.\) for a folder name is shorthand for “this directory”
Two periods (..\) means “the parent folder”
'''

from pathlib import Path

Path('spam') / 'bacon' / 'eggs'
Path('spam') / Path('bacon/eggs')
Path('spam') / Path('bacon', 'eggs')